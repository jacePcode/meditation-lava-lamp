<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Lava Lamp - Immersive 3D Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        canvas { display: block; }
        
        .mood-selector {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 100;
        }
        
        .mood-bubble {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .mood-bubble:hover {
            transform: scale(1.15);
            border-color: rgba(255,255,255,0.6);
        }
        
        .mood-bubble.active {
            border-color: #fff;
            box-shadow: 0 0 25px currentColor;
            transform: scale(1.1);
        }
        
        .mood-cosmic { background: linear-gradient(135deg, #667eea, #764ba2); color: #667eea; }
        .mood-ocean { background: linear-gradient(135deg, #00c6fb, #005bea); color: #00c6fb; }
        .mood-ember { background: linear-gradient(135deg, #f093fb, #f5576c); color: #f5576c; }
        .mood-aurora { background: linear-gradient(135deg, #4facfe, #00f2fe); color: #4facfe; }
        .mood-sunset { background: linear-gradient(135deg, #fa709a, #fee140); color: #fa709a; }
        .mood-nebula { background: linear-gradient(135deg, #a8edea, #fed6e3); color: #a8edea; }
        
        .quality-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        
        .quality-btn {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .quality-btn:hover { background: rgba(255,255,255,0.2); }
        .quality-btn.ultra {
            background: rgba(255,215,0,0.2);
            border-color: rgba(255,215,0,0.5);
        }
        
        .instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.9);
            text-align: center;
            font-size: 16px;
            line-height: 1.8;
            z-index: 100;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.8s ease;
            text-shadow: 0 2px 20px rgba(0,0,0,0.8);
        }
        
        .instructions.hidden { opacity: 0; }
        .instructions h2 { font-size: 28px; margin-bottom: 20px; font-weight: 300; letter-spacing: 2px; }
        .instructions p { opacity: 0.8; }
        
        .audio-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .audio-btn:hover { background: rgba(255,255,255,0.2); }
        .audio-btn svg { width: 20px; height: 20px; }
        .audio-waves { transition: opacity 0.3s ease; opacity: 0.3; }
        .audio-btn.active .audio-waves { opacity: 1; }
        
        .loading {
            position: fixed;
            inset: 0;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }
        
        .loading.hidden { opacity: 0; pointer-events: none; }
        
        .loading-lamp {
            width: 60px;
            height: 120px;
            position: relative;
            margin-bottom: 30px;
        }
        
        .loading-blob {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            animation: blobRise 2s ease-in-out infinite;
        }
        
        @keyframes blobRise {
            0%, 100% { bottom: 20px; transform: translateX(-50%) scale(1); }
            50% { bottom: 80px; transform: translateX(-50%) scale(1.3); }
        }
        
        .loading-text {
            color: #fff;
            font-size: 18px;
            opacity: 0.8;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .fps-counter {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            z-index: 100;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-lamp">
            <div class="loading-blob"></div>
        </div>
        <div class="loading-text">Igniting the lava...</div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div class="instructions" id="instructions">
        <h2>✨ Lava Lamp</h2>
        <p>Tap glass to heat the lava<br>
        Drag to rotate • Pinch to zoom<br>
        Double-tap to reset view</p>
    </div>
    
    <button class="audio-btn" id="audioBtn" title="Toggle Audio">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M11 5L6 9H2v6h4l5 4V5z"/>
            <path class="audio-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"/>
        </svg>
    </button>
    
    <div class="quality-toggle">
        <button class="quality-btn" id="qualityBtn">Quality: High</button>
    </div>
    
    <div class="fps-counter" id="fps"></div>
    
    <div class="mood-selector">
        <div class="mood-bubble mood-cosmic active" data-mood="cosmic" title="Cosmic"></div>
        <div class="mood-bubble mood-ocean" data-mood="ocean" title="Ocean"></div>
        <div class="mood-bubble mood-ember" data-mood="ember" title="Ember"></div>
        <div class="mood-bubble mood-aurora" data-mood="aurora" title="Aurora"></div>
        <div class="mood-bubble mood-sunset" data-mood="sunset" title="Sunset"></div>
        <div class="mood-bubble mood-nebula" data-mood="nebula" title="Nebula"></div>
    </div>

    <!-- Safari-compatible script loading (no importmap) -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    
    <script>
        // Using global THREE object (Safari compatible)

        // ============================================
        // MOOD COLOR SYSTEM
        // ============================================
        const MOODS = {
            cosmic: {
                primary: new THREE.Color(0x667eea),
                secondary: new THREE.Color(0x764ba2),
                emissive: new THREE.Color(0x8b5cf6),
                ambient: 0x0f0f1a,
                gradient: ['#667eea', '#764ba2']
            },
            ocean: {
                primary: new THREE.Color(0x00c6fb),
                secondary: new THREE.Color(0x005bea),
                emissive: new THREE.Color(0x06b6d4),
                ambient: 0x0a1428,
                gradient: ['#00c6fb', '#005bea']
            },
            ember: {
                primary: new THREE.Color(0xf093fb),
                secondary: new THREE.Color(0xf5576c),
                emissive: new THREE.Color(0xff6b6b),
                ambient: 0x1f0a14,
                gradient: ['#f093fb', '#f5576c']
            },
            aurora: {
                primary: new THREE.Color(0x4facfe),
                secondary: new THREE.Color(0x00f2fe),
                emissive: new THREE.Color(0x22d3ee),
                ambient: 0x0a1420,
                gradient: ['#4facfe', '#00f2fe']
            },
            sunset: {
                primary: new THREE.Color(0xfa709a),
                secondary: new THREE.Color(0xfee140),
                emissive: new THREE.Color(0xfb923c),
                ambient: 0x1a100a,
                gradient: ['#fa709a', '#fee140']
            },
            nebula: {
                primary: new THREE.Color(0xa8edea),
                secondary: new THREE.Color(0xfed6e3),
                emissive: new THREE.Color(0xc4b5fd),
                ambient: 0x14101a,
                gradient: ['#a8edea', '#fed6e3']
            }
        };

        let currentMood = 'cosmic';
        let qualityLevel = 'high';

        // ============================================
        // GLOBALS
        // ============================================
        let scene, camera, renderer, composer, controls;
        let lampGroup, glassVessel, lavaVolume;
        let clock = new THREE.Clock();
        let frameCount = 0;
        let lastTime = performance.now();
        
        const LAMP_HEIGHT = 4.5;
        const LAMP_BASE_Y = 0;
        const PARTICLE_COUNT_HIGH = 80;
        const PARTICLE_COUNT_ULTRA = 120;
        
        // ============================================
        // FLUID SIMULATION (SPH-inspired with Metaballs)
        // ============================================
        class LavaSimulation {
            constructor(count) {
                this.particleCount = count;
                this.particles = [];
                this.positions = new Float32Array(count * 4); // x, y, z, size
                this.velocities = [];
                this.temperatures = new Float32Array(count);
                
                this.init();
            }
            
            init() {
                for (let i = 0; i < this.particleCount; i++) {
                    // Start particles in bottom region
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 0.35;
                    const y = 0.7 + Math.random() * 0.8;
                    
                    this.positions[i * 4] = Math.cos(angle) * radius;
                    this.positions[i * 4 + 1] = y;
                    this.positions[i * 4 + 2] = Math.sin(angle) * radius;
                    this.positions[i * 4 + 3] = 0.12 + Math.random() * 0.08; // size
                    
                    this.velocities.push(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.005,
                        (Math.random() - 0.5) * 0.01
                    ));
                    
                    this.temperatures[i] = 0.3 + Math.random() * 0.4;
                }
            }
            
            update(dt, heatPoints, lampProfile) {
                const gravity = -0.005;
                const buoyancy = 0.025;
                const viscosity = 0.96;
                const heatRise = 0.02;
                const coolSink = 0.015;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const idx = i * 4;
                    const pos = new THREE.Vector3(
                        this.positions[idx],
                        this.positions[idx + 1],
                        this.positions[idx + 2]
                    );
                    const vel = this.velocities[i];
                    let temp = this.temperatures[i];
                    
                    // Heat from bottom
                    if (pos.y < 1.5) {
                        temp += (1.5 - pos.y) * 0.008;
                    }
                    
                    // Cool at top
                    if (pos.y > LAMP_HEIGHT - 1.2) {
                        temp -= (pos.y - (LAMP_HEIGHT - 1.2)) * 0.006;
                    }
                    
                    // Heat from interaction points
                    for (const hp of heatPoints) {
                        const dist = pos.distanceTo(hp.position);
                        if (dist < 1.2) {
                            temp += (1.2 - dist) * 0.03;
                            // Attract toward heat
                            const dir = hp.position.clone().sub(pos).normalize();
                            vel.add(dir.multiplyScalar(0.008 * (1.2 - dist)));
                        }
                    }
                    
                    temp = Math.max(0, Math.min(1, temp));
                    this.temperatures[i] = temp;
                    
                    // Buoyancy based on temperature
                    const buoyancyForce = (temp - 0.5) * buoyancy;
                    vel.y += buoyancyForce;
                    
                    // Gravity
                    vel.y += gravity;
                    
                    // Particle-particle interaction (simplified SPH)
                    for (let j = 0; j < this.particleCount; j++) {
                        if (i === j) continue;
                        const jdx = j * 4;
                        const otherPos = new THREE.Vector3(
                            this.positions[jdx],
                            this.positions[jdx + 1],
                            this.positions[jdx + 2]
                        );
                        const diff = pos.clone().sub(otherPos);
                        const dist = diff.length();
                        
                        if (dist < 0.4 && dist > 0.01) {
                            // Soft repulsion
                            const force = diff.normalize().multiplyScalar(0.003 / (dist * dist + 0.01));
                            vel.add(force);
                            
                            // Hot particles attract slightly (merging)
                            if (temp > 0.6 && this.temperatures[j] > 0.6 && dist > 0.15) {
                                vel.sub(force.multiplyScalar(0.3));
                            }
                        }
                    }
                    
                    // Viscosity
                    vel.multiplyScalar(viscosity);
                    
                    // Clamp velocity
                    vel.clampLength(0, 0.08);
                    
                    // Update position
                    pos.add(vel.clone().multiplyScalar(dt * 60));
                    
                    // Constrain to lamp shape
                    this.constrainToLamp(pos, vel, i);
                    
                    // Write back
                    this.positions[idx] = pos.x;
                    this.positions[idx + 1] = pos.y;
                    this.positions[idx + 2] = pos.z;
                    
                    // Size pulsing based on temperature
                    const targetSize = 0.12 + temp * 0.08 + Math.sin(clock.getElapsedTime() * 2 + i) * 0.015;
                    this.positions[idx + 3] += (targetSize - this.positions[idx + 3]) * 0.1;
                }
            }
            
            constrainToLamp(pos, vel, particleIndex) {
                // Vertical bounds
                const minY = 0.65;
                const maxY = LAMP_HEIGHT - 0.7;
                
                if (pos.y < minY) {
                    pos.y = minY;
                    vel.y *= -0.3;
                }
                if (pos.y > maxY) {
                    pos.y = maxY;
                    vel.y *= -0.3;
                }
                
                // Get lamp radius at this height
                const heightRatio = (pos.y - 0.4) / (LAMP_HEIGHT - 0.8);
                let maxRadius;
                
                if (heightRatio < 0.05) {
                    maxRadius = 0.35;
                } else if (heightRatio < 0.15) {
                    maxRadius = 0.35 + (heightRatio - 0.05) * 3;
                } else if (heightRatio < 0.35) {
                    maxRadius = 0.65 + Math.sin((heightRatio - 0.15) * Math.PI / 0.2) * 0.08;
                } else if (heightRatio < 0.65) {
                    maxRadius = 0.65 - (heightRatio - 0.35) * 0.15;
                } else if (heightRatio < 0.85) {
                    maxRadius = 0.60 - (heightRatio - 0.65) * 0.5;
                } else {
                    maxRadius = Math.max(0.1, 0.50 - (heightRatio - 0.85) * 1.5);
                }
                
                maxRadius = Math.max(0.1, maxRadius - 0.1);
                
                const horizontalDist = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                if (horizontalDist > maxRadius) {
                    const scale = maxRadius / horizontalDist;
                    pos.x *= scale;
                    pos.z *= scale;
                    
                    // Bounce
                    const normal = new THREE.Vector3(pos.x, 0, pos.z).normalize();
                    const dot = vel.dot(normal);
                    if (dot > 0) {
                        vel.sub(normal.multiplyScalar(dot * 1.5));
                    }
                }
            }
        }

        let lavaSim;
        let lavaMaterial;
        let heatPoints = [];

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(MOODS[currentMood].ambient);
            scene.fog = new THREE.Fog(MOODS[currentMood].ambient, 8, 20);
            
            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 2.5, 5.5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, qualityLevel === 'ultra' ? 3 : 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Post-processing
            setupPostProcessing();
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI * 0.85;
            controls.minPolarAngle = Math.PI * 0.15;
            controls.target.set(0, LAMP_HEIGHT / 2, 0);
            
            // Double-tap reset
            let lastTap = 0;
            renderer.domElement.addEventListener('pointerdown', (e) => {
                const now = Date.now();
                if (now - lastTap < 300) {
                    resetCamera();
                }
                lastTap = now;
            });
            
            // Create scene elements
            createEnvironment();
            createLamp();
            initLavaSimulation();
            setupLighting();
            setupInteraction();
            
            // Events
            window.addEventListener('resize', onWindowResize);
            
            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                setTimeout(() => {
                    document.getElementById('instructions').classList.add('hidden');
                }, 5000);
            }, 1500);
            
            animate();
        }

        // ============================================
        // POST-PROCESSING
        // ============================================
        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Bloom for glow effect
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2,
                0.5,
                0.7
            );
            composer.addPass(bloomPass);
            
            // God rays shader
            const godRaysShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    uLightPos: { value: new THREE.Vector2(0.5, 0.6) },
                    uExposure: { value: 0.3 },
                    uDecay: { value: 0.95 },
                    uDensity: { value: 0.6 },
                    uWeight: { value: 0.4 },
                    uSamples: { value: 50 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 uLightPos;
                    uniform float uExposure;
                    uniform float uDecay;
                    uniform float uDensity;
                    uniform float uWeight;
                    uniform int uSamples;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 deltaTexCoord = (vUv - uLightPos) * (1.0 / float(uSamples)) * uDensity;
                        vec2 texCoord = vUv;
                        vec4 color = texture2D(tDiffuse, texCoord);
                        float illuminationDecay = 1.0;
                        
                        for(int i = 0; i < 50; i++) {
                            if(i >= uSamples) break;
                            texCoord -= deltaTexCoord;
                            vec4 sample_color = texture2D(tDiffuse, texCoord);
                            sample_color *= illuminationDecay * uWeight;
                            color += sample_color;
                            illuminationDecay *= uDecay;
                        }
                        
                        gl_FragColor = color * uExposure;
                    }
                `
            };
            
            const godRaysPass = new ShaderPass(godRaysShader);
            composer.addPass(godRaysPass);
        }

        // ============================================
        // LAMP MODEL
        // ============================================
        function createLamp() {
            lampGroup = new THREE.Group();
            
            // Chrome base
            const baseProfile = [
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0.78, 0),
                new THREE.Vector2(0.85, 0.03),
                new THREE.Vector2(0.72, 0.12),
                new THREE.Vector2(0.55, 0.3),
                new THREE.Vector2(0.48, 0.38)
            ];
            
            const baseGeometry = new THREE.LatheGeometry(baseProfile, 64);
            
            const chromeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.98,
                roughness: 0.02,
                envMapIntensity: 2
            });
            
            const base = new THREE.Mesh(baseGeometry, chromeMaterial);
            lampGroup.add(base);
            
            // Glass vessel
            const glassProfile = createGlassProfile();
            const glassGeometry = new THREE.LatheGeometry(glassProfile, 64);
            
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0,
                roughness: 0.02,
                transmission: 0.98,
                thickness: 0.3,
                ior: 1.5,
                clearcoat: 1,
                clearcoatRoughness: 0.05,
                envMapIntensity: 1,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            glassVessel = new THREE.Mesh(glassGeometry, glassMaterial);
            glassVessel.position.y = 0.38;
            lampGroup.add(glassVessel);
            
            // Chrome cap
            const capProfile = [
                new THREE.Vector2(0, LAMP_HEIGHT - 0.35),
                new THREE.Vector2(0.3, LAMP_HEIGHT - 0.32),
                new THREE.Vector2(0.42, LAMP_HEIGHT - 0.28),
                new THREE.Vector2(0.48, LAMP_HEIGHT - 0.22),
                new THREE.Vector2(0.45, LAMP_HEIGHT - 0.15),
                new THREE.Vector2(0.35, LAMP_HEIGHT - 0.1),
                new THREE.Vector2(0.15, LAMP_HEIGHT - 0.08),
                new THREE.Vector2(0, LAMP_HEIGHT - 0.08)
            ];
            
            const capGeometry = new THREE.LatheGeometry(capProfile, 64);
            const cap = new THREE.Mesh(capGeometry, chromeMaterial);
            lampGroup.add(cap);
            
            // Decorative ring at base of glass
            const ringGeometry = new THREE.TorusGeometry(0.50, 0.018, 16, 64);
            const baseRing = new THREE.Mesh(ringGeometry, chromeMaterial);
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = 0.42;
            lampGroup.add(baseRing);
            
            // Ring at top of glass
            const topRing = baseRing.clone();
            topRing.position.y = LAMP_HEIGHT - 0.48;
            lampGroup.add(topRing);
            
            scene.add(lampGroup);
        }
        
        function createGlassProfile() {
            const points = [];
            const segments = 60;
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const y = t * (LAMP_HEIGHT - 0.85);
                
                let x;
                if (t < 0.05) {
                    // Base transition
                    x = 0.45 + t * 2;
                } else if (t < 0.2) {
                    // Lower bulge
                    const lt = (t - 0.05) / 0.15;
                    x = 0.55 + Math.sin(lt * Math.PI) * 0.12;
                } else if (t < 0.5) {
                    // Main body - slight taper
                    const lt = (t - 0.2) / 0.3;
                    x = 0.62 - lt * 0.05 + Math.sin(lt * Math.PI * 1.5) * 0.03;
                } else if (t < 0.75) {
                    // Upper body
                    const lt = (t - 0.5) / 0.25;
                    x = 0.57 - lt * 0.12;
                } else {
                    // Neck and top
                    const lt = (t - 0.75) / 0.25;
                    x = 0.45 - lt * 0.08;
                }
                
                points.push(new THREE.Vector2(x, y));
            }
            
            return points;
        }

        // ============================================
        // LAVA SIMULATION & RENDERING
        // ============================================
        function initLavaSimulation() {
            const count = qualityLevel === 'ultra' ? PARTICLE_COUNT_ULTRA : PARTICLE_COUNT_HIGH;
            lavaSim = new LavaSimulation(count);
            
            // Create metaball shader material
            lavaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uParticles: { value: lavaSim.positions },
                    uParticleCount: { value: count },
                    uColor1: { value: MOODS[currentMood].primary },
                    uColor2: { value: MOODS[currentMood].secondary },
                    uEmissive: { value: MOODS[currentMood].emissive },
                    uLampBoundsMin: { value: new THREE.Vector3(-0.5, 0.5, -0.5) },
                    uLampBoundsMax: { value: new THREE.Vector3(0.5, LAMP_HEIGHT - 0.6, 0.5) }
                },
                vertexShader: `
                    attribute float aSize;
                    attribute float aTemperature;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying float vTemperature;
                    varying float vSize;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normalize(normalMatrix * normal);
                        vTemperature = aTemperature;
                        vSize = aSize;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = aSize * 800.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform vec3 uEmissive;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying float vTemperature;
                    varying float vSize;
                    
                    void main() {
                        // Circular point with soft edge
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        
                        // Soft blobby edge
                        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                        
                        // Height-based color gradient
                        float heightRatio = (vPosition.y - 0.5) / 3.5;
                        vec3 baseColor = mix(uColor1, uColor2, heightRatio);
                        
                        // Temperature-based intensity
                        float tempGlow = vTemperature * 0.5 + 0.5;
                        
                        // Fresnel-like rim lighting
                        vec3 viewDir = normalize(cameraPosition - vPosition);
                        float rim = pow(1.0 - abs(dot(viewDir, vNormal)), 2.0);
                        
                        // Internal glow (subsurface scattering approximation)
                        float internalGlow = (1.0 - dist * 2.0) * tempGlow;
                        
                        // Pulsing effect
                        float pulse = sin(uTime * 2.0 + vPosition.y * 2.0) * 0.1 + 0.9;
                        
                        // Combine colors
                        vec3 finalColor = baseColor * tempGlow;
                        finalColor += uEmissive * internalGlow * pulse;
                        finalColor += uEmissive * rim * 0.3;
                        
                        // Extra glow at core
                        finalColor += uEmissive * (1.0 - dist * 2.0) * 0.4 * tempGlow;
                        
                        gl_FragColor = vec4(finalColor, alpha * 0.92);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            // Create points geometry
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const temperatures = new Float32Array(count);
            
            for (let i = 0; i < count; i++) {
                positions[i * 3] = lavaSim.positions[i * 4];
                positions[i * 3 + 1] = lavaSim.positions[i * 4 + 1];
                positions[i * 3 + 2] = lavaSim.positions[i * 4 + 2];
                sizes[i] = lavaSim.positions[i * 4 + 3];
                temperatures[i] = lavaSim.temperatures[i];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aTemperature', new THREE.BufferAttribute(temperatures, 1));
            
            lavaVolume = new THREE.Points(geometry, lavaMaterial);
            lavaVolume.position.y = 0.38;
            lampGroup.add(lavaVolume);
            
            // Create connecting blobs for merged look
            createBlobConnectors();
        }
        
        // Create additional metaball-like connections
        function createBlobConnectors() {
            const connectorMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor1: { value: MOODS[currentMood].primary },
                    uColor2: { value: MOODS[currentMood].secondary },
                    uEmissive: { value: MOODS[currentMood].emissive }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uTime;
                    uniform vec3 uColor1;
                    uniform vec3 uColor2;
                    uniform vec3 uEmissive;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        float heightRatio = (vPosition.y - 0.5) / 3.5;
                        vec3 baseColor = mix(uColor1, uColor2, heightRatio);
                        
                        vec3 viewDir = normalize(cameraPosition - vPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), 2.5);
                        
                        vec3 color = baseColor + uEmissive * fresnel * 0.5;
                        color += uEmissive * 0.3 * (1.0 - fresnel);
                        
                        gl_FragColor = vec4(color, 0.7);
                    }
                `,
                transparent: true,
                depthWrite: false,
                side: THREE.DoubleSide
            });
        }

        function updateLava(dt) {
            lavaSim.update(dt, heatPoints);
            
            // Update geometry
            const positions = lavaVolume.geometry.attributes.position.array;
            const sizes = lavaVolume.geometry.attributes.aSize.array;
            const temperatures = lavaVolume.geometry.attributes.aTemperature.array;
            
            for (let i = 0; i < lavaSim.particleCount; i++) {
                positions[i * 3] = lavaSim.positions[i * 4];
                positions[i * 3 + 1] = lavaSim.positions[i * 4 + 1];
                positions[i * 3 + 2] = lavaSim.positions[i * 4 + 2];
                sizes[i] = lavaSim.positions[i * 4 + 3] * 30; // Scale for point size
                temperatures[i] = lavaSim.temperatures[i];
            }
            
            lavaVolume.geometry.attributes.position.needsUpdate = true;
            lavaVolume.geometry.attributes.aSize.needsUpdate = true;
            lavaVolume.geometry.attributes.aTemperature.needsUpdate = true;
            
            lavaMaterial.uniforms.uTime.value = clock.getElapsedTime();
        }

        // ============================================
        // LIGHTING
        // ============================================
        let pointLight, ambientLight;
        
        function setupLighting() {
            // Ambient
            ambientLight = new THREE.AmbientLight(0x404050, 0.4);
            scene.add(ambientLight);
            
            // Main internal light
            pointLight = new THREE.PointLight(MOODS[currentMood].emissive, 3, 10);
            pointLight.position.set(0, 1.8, 0);
            lampGroup.add(pointLight);
            
            // Secondary glow light
            const glowLight = new THREE.PointLight(MOODS[currentMood].primary, 1.5, 6);
            glowLight.position.set(0, 3, 0);
            lampGroup.add(glowLight);
            
            // Rim lights
            const rimLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
            rimLight1.position.set(4, 3, 4);
            scene.add(rimLight1);
            
            const rimLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            rimLight2.position.set(-4, 2, -4);
            scene.add(rimLight2);
            
            // Create environment map
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            envScene.background = new THREE.Color(0x0f0f1a);
            
            const envLight1 = new THREE.PointLight(0x667eea, 4, 15);
            envLight1.position.set(3, 4, 3);
            envScene.add(envLight1);
            
            const envLight2 = new THREE.PointLight(0xf5576c, 3, 15);
            envLight2.position.set(-3, 2, -3);
            envScene.add(envLight2);
            
            const envMap = pmremGenerator.fromScene(envScene).texture;
            scene.environment = envMap;
        }

        // ============================================
        // ENVIRONMENT
        // ============================================
        function createEnvironment() {
            // Reflective floor
            const floorGeometry = new THREE.CircleGeometry(12, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a10,
                metalness: 0.9,
                roughness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.01;
            scene.add(floor);
            
            // Background particles
            const bgCount = 300;
            const bgGeometry = new THREE.BufferGeometry();
            const bgPositions = new Float32Array(bgCount * 3);
            
            for (let i = 0; i < bgCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 6 + Math.random() * 8;
                
                bgPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                bgPositions[i * 3 + 1] = r * Math.cos(phi);
                bgPositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
            }
            
            bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
            
            const bgMaterial = new THREE.PointsMaterial({
                color: MOODS[currentMood].primary,
                size: 0.04,
                transparent: true,
                opacity: 0.5,
                sizeAttenuation: true
            });
            
            const bgParticles = new THREE.Points(bgGeometry, bgMaterial);
            bgParticles.name = 'bgParticles';
            scene.add(bgParticles);
        }

        // ============================================
        // INTERACTION
        // ============================================
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let currentHeatPoint = null;
        let isLongPress = false;
        let longPressTimer = null;
        
        function setupInteraction() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointercancel', onPointerUp);
            
            // Mood selection
            document.querySelectorAll('.mood-bubble').forEach(bubble => {
                bubble.addEventListener('click', () => {
                    document.querySelectorAll('.mood-bubble').forEach(b => b.classList.remove('active'));
                    bubble.classList.add('active');
                    setMood(bubble.dataset.mood);
                });
            });
            
            // Quality toggle
            document.getElementById('qualityBtn').addEventListener('click', toggleQuality);
            
            // Audio toggle
            document.getElementById('audioBtn').addEventListener('click', toggleAudio);
        }
        
        function onPointerDown(e) {
            isLongPress = false;
            clearTimeout(longPressTimer);
            longPressTimer = setTimeout(() => { isLongPress = true; }, 400);
            
            updatePointer(e);
            raycaster.setFromCamera(pointer, camera);
            
            const intersects = raycaster.intersectObject(glassVessel);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                currentHeatPoint = { position: point, startTime: Date.now() };
                heatPoints.push(currentHeatPoint);
            }
        }
        
        function onPointerMove(e) {
            if (currentHeatPoint) {
                updatePointer(e);
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(glassVessel);
                if (intersects.length > 0) {
                    currentHeatPoint.position = intersects[0].point;
                }
            }
        }
        
        function onPointerUp() {
            clearTimeout(longPressTimer);
            if (currentHeatPoint) {
                const hp = currentHeatPoint;
                setTimeout(() => {
                    const idx = heatPoints.indexOf(hp);
                    if (idx > -1) heatPoints.splice(idx, 1);
                }, isLongPress ? 2500 : 800);
            }
            currentHeatPoint = null;
            isLongPress = false;
        }
        
        function updatePointer(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        // ============================================
        // MOOD SYSTEM
        // ============================================
        function setMood(mood) {
            currentMood = mood;
            const config = MOODS[mood];
            
            scene.background = new THREE.Color(config.ambient);
            scene.fog.color = new THREE.Color(config.ambient);
            
            lavaMaterial.uniforms.uColor1.value = config.primary;
            lavaMaterial.uniforms.uColor2.value = config.secondary;
            lavaMaterial.uniforms.uEmissive.value = config.emissive;
            
            pointLight.color = config.emissive;
            
            const bgParticles = scene.getObjectByName('bgParticles');
            if (bgParticles) bgParticles.material.color = config.primary;
            
            if (audioContext && audioEnabled) playChime(config.emissive);
        }

        // ============================================
        // QUALITY TOGGLE
        // ============================================
        function toggleQuality() {
            const btn = document.getElementById('qualityBtn');
            qualityLevel = qualityLevel === 'high' ? 'ultra' : 'high';
            btn.textContent = `Quality: ${qualityLevel.charAt(0).toUpperCase() + qualityLevel.slice(1)}`;
            btn.classList.toggle('ultra', qualityLevel === 'ultra');
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, qualityLevel === 'ultra' ? 3 : 2));
            
            // Reinit simulation with new particle count
            lampGroup.remove(lavaVolume);
            initLavaSimulation();
        }

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        let audioContext = null;
        let audioEnabled = false;
        let masterGain = null;
        let droneOscillators = [];
        let lastChimeTime = 0;
        
        function initAudio() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0;
            masterGain.connect(audioContext.destination);
            createDrone();
        }
        
        function createDrone() {
            const baseFreq = 55;
            const freqs = [baseFreq, baseFreq * 1.5, baseFreq * 2, baseFreq * 3];
            
            freqs.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                
                osc.type = i % 2 === 0 ? 'sine' : 'triangle';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 600 + Math.random() * 300;
                
                gain.gain.value = 0.08 / (i + 1);
                
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.value = 0.05 + Math.random() * 0.15;
                lfoGain.gain.value = freq * 0.015;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                lfo.start();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(masterGain);
                osc.start();
                
                droneOscillators.push({ osc, gain, filter, lfo });
            });
        }
        
        function playChime(color) {
            if (!audioContext || !audioEnabled) return;
            
            const now = Date.now();
            if (now - lastChimeTime < 150) return;
            lastChimeTime = now;
            
            const hsl = { h: 0, s: 0, l: 0 };
            color.getHSL(hsl);
            const baseFreq = 300 + hsl.h * 400;
            
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc.type = 'sine';
            osc.frequency.value = baseFreq * (1 + Math.random() * 0.05);
            
            filter.type = 'bandpass';
            filter.frequency.value = baseFreq;
            filter.Q.value = 8;
            
            gain.gain.setValueAtTime(0.15, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(masterGain);
            
            osc.start();
            osc.stop(audioContext.currentTime + 1.2);
        }
        
        function toggleAudio() {
            if (!audioContext) initAudio();
            
            audioEnabled = !audioEnabled;
            const btn = document.getElementById('audioBtn');
            btn.classList.toggle('active', audioEnabled);
            
            if (audioEnabled) {
                if (audioContext.state === 'suspended') audioContext.resume();
                masterGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.5);
            } else {
                masterGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.05);
            frameCount++;
            
            // FPS counter
            if (frameCount % 30 === 0) {
                const now = performance.now();
                const fps = Math.round(30000 / (now - lastTime));
                document.getElementById('fps').textContent = `${fps} FPS`;
                lastTime = now;
            }
            
            // Update lava
            updateLava(dt);
            
            // Update controls
            controls.update();
            
            // Animate lights
            const time = clock.getElapsedTime();
            pointLight.intensity = 3 + Math.sin(time * 1.3) * 0.4;
            pointLight.position.y = 1.8 + Math.sin(time * 0.4) * 0.15;
            
            // Rotate background
            const bgParticles = scene.getObjectByName('bgParticles');
            if (bgParticles) bgParticles.rotation.y += 0.0003;
            
            // Subtle lamp rotation
            lampGroup.rotation.y = Math.sin(time * 0.15) * 0.015;
            
            // Check for blob merges - play chimes
            if (frameCount % 45 === 0 && audioEnabled) {
                checkBlobMerges();
            }
            
            // Render
            composer.render();
        }
        
        function checkBlobMerges() {
            for (let i = 0; i < lavaSim.particleCount; i++) {
                for (let j = i + 1; j < lavaSim.particleCount; j++) {
                    const dx = lavaSim.positions[i*4] - lavaSim.positions[j*4];
                    const dy = lavaSim.positions[i*4+1] - lavaSim.positions[j*4+1];
                    const dz = lavaSim.positions[i*4+2] - lavaSim.positions[j*4+2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    if (dist < 0.18 && lavaSim.temperatures[i] > 0.5 && lavaSim.temperatures[j] > 0.5) {
                        if (Math.random() < 0.08) {
                            playChime(MOODS[currentMood].emissive);
                        }
                        break;
                    }
                }
            }
        }

        // ============================================
        // UTILITIES
        // ============================================
        function resetCamera() {
            const targetPos = new THREE.Vector3(0, 2.5, 5.5);
            const startPos = camera.position.clone();
            const duration = 800;
            const startTime = Date.now();
            
            function animateReset() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - t, 3);
                
                camera.position.lerpVectors(startPos, targetPos, eased);
                controls.target.lerp(new THREE.Vector3(0, LAMP_HEIGHT / 2, 0), eased * 0.1);
                
                if (t < 1) requestAnimationFrame(animateReset);
            }
            animateReset();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // WEBGL CONTEXT HANDLING
        // ============================================
        document.addEventListener('webglcontextlost', (e) => {
            e.preventDefault();
            console.warn('WebGL context lost');
        });
        
        document.addEventListener('webglcontextrestored', () => {
            console.log('WebGL context restored');
            init();
        });

        // Start
        init();
        
        // Debug API
        window.lavaLamp = {
            setMood,
            toggleQuality,
            toggleAudio,
            resetCamera,
            getStats: () => ({
                particles: lavaSim.particleCount,
                quality: qualityLevel,
                mood: currentMood
            })
        };
    </script>
</body>
</html>
